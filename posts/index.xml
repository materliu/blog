<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 知了</title>
    <link>https://materliu.github.io/blog/posts/</link>
    <description>Recent content in Posts on 知了</description>
    <image>
      <url>https://materliu.github.io/blog/papermod-cover.png</url>
      <link>https://materliu.github.io/blog/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 06 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://materliu.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>电动车遥控器丢了怎么办</title>
      <link>https://materliu.github.io/blog/posts/electric-bike-remote-lost/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/electric-bike-remote-lost/</guid>
      <description>钥匙丢了可以配，电动遥控器丢了怎么配呢</description>
    </item>
    
    <item>
      <title>mac使用快捷键command tab切换程序</title>
      <link>https://materliu.github.io/blog/posts/2014-01-01-mac-cycle-applications/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-01-01-mac-cycle-applications/</guid>
      <description>日增一技</description>
    </item>
    
    <item>
      <title>personal photos</title>
      <link>https://materliu.github.io/blog/posts/personal-photos/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/personal-photos/</guid>
      <description>show yourself</description>
    </item>
    
    <item>
      <title>成语收录</title>
      <link>https://materliu.github.io/blog/posts/idiom/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/idiom/</guid>
      <description>一些俏皮话的整理</description>
    </item>
    
    <item>
      <title>道德修养</title>
      <link>https://materliu.github.io/blog/posts/2014-04-12-%E9%81%93%E5%BE%B7%E4%BF%AE%E5%85%BB/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-12-%E9%81%93%E5%BE%B7%E4%BF%AE%E5%85%BB/</guid>
      <description>君子善于自省</description>
    </item>
    
    <item>
      <title>二哥跟我讲的一些简单的股市知识整理</title>
      <link>https://materliu.github.io/blog/posts/2014-03-30-%E4%BA%8C%E5%93%A5%E8%B7%9F%E6%88%91%E8%AE%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%82%A1%E5%B8%82%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-03-30-%E4%BA%8C%E5%93%A5%E8%B7%9F%E6%88%91%E8%AE%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%82%A1%E5%B8%82%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</guid>
      <description>日增一技</description>
    </item>
    
    <item>
      <title>精彩破场</title>
      <link>https://materliu.github.io/blog/posts/2014-04-12-%E7%B2%BE%E5%BD%A9%E7%A0%B4%E5%9C%BA/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-12-%E7%B2%BE%E5%BD%A9%E7%A0%B4%E5%9C%BA/</guid>
      <description>尴尬不？</description>
    </item>
    
    <item>
      <title>日本海淘</title>
      <link>https://materliu.github.io/blog/posts/2014-04-12-%E6%97%A5%E6%9C%AC%E6%B5%B7%E6%B7%98/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-12-%E6%97%A5%E6%9C%AC%E6%B5%B7%E6%B7%98/</guid>
      <description>日增一技</description>
    </item>
    
    <item>
      <title>微小说收录</title>
      <link>https://materliu.github.io/blog/posts/2014-04-12-%E5%BE%AE%E5%B0%8F%E8%AF%B4%E6%94%B6%E5%BD%95/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-12-%E5%BE%AE%E5%B0%8F%E8%AF%B4%E6%94%B6%E5%BD%95/</guid>
      <description>尴尬不？</description>
    </item>
    
    <item>
      <title>职场忠告</title>
      <link>https://materliu.github.io/blog/posts/2014-04-12-%E8%81%8C%E5%9C%BA%E5%BF%A0%E5%91%8A/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-12-%E8%81%8C%E5%9C%BA%E5%BF%A0%E5%91%8A/</guid>
      <description>尴尬不？</description>
    </item>
    
    <item>
      <title>Markdown Syntax Guide For L2</title>
      <link>https://materliu.github.io/blog/posts/markdown-syntax/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/markdown-syntax/</guid>
      <description>Sample article showcasing basic Markdown syntax and formatting for HTML elements.</description>
    </item>
    
    <item>
      <title>QQ大数据告诉你有多少人逃离北上广</title>
      <link>https://materliu.github.io/blog/posts/2014-03-12-qq%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%91%8A%E8%AF%89%E4%BD%A0%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BA%BA%E9%80%83%E7%A6%BB%E5%8C%97%E4%B8%8A%E5%B9%BF/</link>
      <pubDate>Tue, 04 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-03-12-qq%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%91%8A%E8%AF%89%E4%BD%A0%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BA%BA%E9%80%83%E7%A6%BB%E5%8C%97%E4%B8%8A%E5%B9%BF/</guid>
      <description>日增一技</description>
    </item>
    
    <item>
      <title>Sass与Compass译者序</title>
      <link>https://materliu.github.io/blog/posts/2014-03-10-sass%E4%B8%8Ecompass%E8%AF%91%E8%80%85%E5%BA%8F/</link>
      <pubDate>Tue, 04 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-03-10-sass%E4%B8%8Ecompass%E8%AF%91%E8%80%85%E5%BA%8F/</guid>
      <description>日增一技</description>
    </item>
    
    <item>
      <title>移动webapp开发必备知识</title>
      <link>https://materliu.github.io/blog/posts/2015-09-23-mobile-development/</link>
      <pubDate>Tue, 04 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2015-09-23-mobile-development/</guid>
      <description>日增一技</description>
    </item>
    
    <item>
      <title>Rich Content</title>
      <link>https://materliu.github.io/blog/posts/rich-content/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/rich-content/</guid>
      <description>A brief description of Hugo Shortcodes</description>
    </item>
    
    <item>
      <title>Placeholder Text</title>
      <link>https://materliu.github.io/blog/posts/placeholder-text/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/placeholder-text/</guid>
      <description>Lorem Ipsum Dolor Si Amet</description>
    </item>
    
    <item>
      <title>Math Typesetting</title>
      <link>https://materliu.github.io/blog/posts/math-typesetting/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/math-typesetting/</guid>
      <description>A brief guide to setup KaTeX</description>
    </item>
    
    <item>
      <title>Emoji Support</title>
      <link>https://materliu.github.io/blog/posts/emoji-support/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/emoji-support/</guid>
      <description>Guide to emoji usage in Hugo</description>
    </item>
    
    <item>
      <title>Compile-make-build的区别</title>
      <link>https://materliu.github.io/blog/posts/2014-04-28-comile-make-build-difference/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-28-comile-make-build-difference/</guid>
      <description>Compile-make-build的区别 Compile、Make和Build的区别 针对Java的开发工具，一般都有Compile、Make和Build三个菜单项，完成的功能的都差不多，但是又有区别。 编译，是将源代码转换为可执行代码的过程。编译需要指定源文件和编译输出的文件路径（输出目录）。Java的编译会将java编译为class文件，将非java的文件（一般成为资源文件、比如图片、xml、txt、poperties等文件）原封不动的复制到编译输出目录，并保持源文件夹的目录层次关系。 在Java的集成开发环境中，比如Eclipse、IDEA中，有常常有三种与编译相关的选项Compile、Make、Build三个选项。这三个选项最基本的功能都是完成编译过程。但又有很大的区别，区别如下： 1、Compile：只编译选定的目标，不管之前是否已经编译过。 2、Make：编译选定的目标，但是Make只编译上次编译变化过的文件，减少重复劳动，节省时间。（具体怎么检查未变化，这个就不用考虑了，IDE自己内部会搞定这些的） 3、Build：是对整个工程进行彻底的重新编译，而不管是否已经编译过。Build过程往往会生成发布包，这个具体要看对IDE的配置了，Build在实际中应用很少，因为开发时候基本上不用，发布生产时候一般都用ANT等工具来发布。Build因为要全部编译，还要执行打包等额外工作，因此时间较长。</description>
    </item>
    
    <item>
      <title>cookie作用域，用户隐私信息</title>
      <link>https://materliu.github.io/blog/posts/2014-04-27-cookie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-27-cookie/</guid>
      <description>cookie作用域，用户隐私信息 cookies作用域：即cookie的domain属性，作用为约束子域是否可以共享主域的Cookies，公司cookies作用域通常为qq.com
用户隐私：用户的个人信息，包括明文、加密、内部编码等存储形式，包括但不限于以下信息：
－能唯一标识用户的信息， 如用户账号、密码、邮箱、手机号等 －与用户相关的信息， 如用户性别、年龄段、月收入、地域等 －用户的上网行为记录， 如搜索关系词、浏览的页面、上网时长、收藏的商品等 －用户机器的硬件信息，如CPU参数、内存参数、硬盘参数等 －等等
这里详细讲一下cookie的作用域：
如何让不同子域共享一份cookie呢？
网上有个小哥写的一段挺好：
so you are using cookies on your website, but when a visitor visits www.yourdomain.com and yourdomain.com the cookie doesn’t get set across both! That is because in essence, www. is simply a subdomain. The “www” component is not a protocol, it is not necessary, instead all it is, is just a marketing ploy. But anyway. Here is what you would do normally:</description>
    </item>
    
    <item>
      <title>ctrl&#43;f5强制刷新，浏览器干了哪些事情</title>
      <link>https://materliu.github.io/blog/posts/2014-04-17-browser-ctrl-f5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-17-browser-ctrl-f5/</guid>
      <description>ctrl+f5强制刷新，浏览器干了哪些事情   ctrl+f5 会强制在资源请求头中加上
Cache-Control: no-cache
Pragma: no-cache
  f5 会强制在资源请求头中加上
Cache-Control: max-age=0
有可能会带 if-modified-since:
  HTTP协议说明 HTTP/1.1规范14.9.4中规定：
End-to-end reload(即CTRL-F5强制刷新)会发送如下HTTP头： Cache-Control: no-cache Pragma: no-cache
Specific end-to-end revalidation(即F5 刷新)会发送如下HTTP头： Cache-Control: max-age=0 If-Modified-Since: Fri, 15 Apr 2011 12:08:21 GMT
  补充2中说的可能的原因
A request with If-Modified-Since makes only sense if the client has already a resource which is obtained along a response with a Last-Modified header in combination with headers which allow browser caching like a Cache-Control and/or Pragma value containing public.</description>
    </item>
    
    <item>
      <title>javascript_error_type</title>
      <link>https://materliu.github.io/blog/posts/2014-04-28-javascript_error_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-28-javascript_error_type/</guid>
      <description>javascript_error_type Error
Base type for all errors. Never actually thrown by the engine.
EvalError
Thrown when an error occurs during execution of code via eval().
RangeError
Thrown when a number is outside the bounds of its range—for example, trying to create an array with –20 items (new Array(-20)). These errors rarely occur during normal execution.
ReferenceError
Thrown when an object is expected but not available—for instance, trying to call a method on a null reference.</description>
    </item>
    
    <item>
      <title>new_Image()上报存在缺陷</title>
      <link>https://materliu.github.io/blog/posts/2014-03-27-new_image%E4%B8%8A%E6%8A%A5%E5%AD%98%E5%9C%A8%E7%BC%BA%E9%99%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-03-27-new_image%E4%B8%8A%E6%8A%A5%E5%AD%98%E5%9C%A8%E7%BC%BA%E9%99%B7/</guid>
      <description>##使用new Image().src=&amp;ldquo;http://&amp;hellip;&amp;hellip;&amp;ldquo;进行数据上报存在缺陷
目前,我们的数据统计基本上都在页面由js来完成,而js通常使用如下的代码的进行数据上报:new Image().src=&amp;ldquo;http://&amp;hellip;&amp;hellip;&amp;rdquo; 这种用法在firefox下没有问题,但在ie下有问题. 如果js在执行该语句之后立即进行其它http请求,会导致该数据上报的http请求被中止(使用httpwatch,提示aborted).[注:这种情况的发生不是必现,有时也能上报成功]. 使用google和baidu搜索,没有找到权威的解释.我个人认为这可能是由于ie的处理http请求队列的策略导致.由于new Image创建的的Image DOM对象没有挂载到页面Body,请求该Image的数据对页面的展示没有任何的意义,ie在http请求忙的时候会主动中止这类请求.[敝人之见,欢迎大家讨论]. 解决的方案是把上面的代码改为: var objImg = new Image(); objImg.style.width = 0; objImg.style.height = 0; document.body.appendChild(objImg); objImg.src = &amp;ldquo;http://&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;rdquo;</description>
    </item>
    
    <item>
      <title>publish你自己的node_modules</title>
      <link>https://materliu.github.io/blog/posts/2014-04-04-publish%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84node_modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-04-publish%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84node_modules/</guid>
      <description>为了迎合蛋疼的业务需求， 写了一个修改本地localhost的grunt插件， 具体内容见
说一下发布到官网npm库的流程
官方的npm注册地址是： http://registry.npmjs.org/
首先访问http://www.npmjs.org, 注册一个你自己的账号。
然后在本地命令行中： npm adduser 把刚刚注册的账号根据命令行提示， 添加进去。
如果项目已经在github提交，接下来就非常方便了，这也是我推荐的方式：
所有github的项目都可以通过地址 https://github.com/materliu/grunt-localhosts/tarball/master 将你的项目master打包下载
注意修改 materliu/grunt-localhosts 为你的项目名
而npm publish 支持直接通过 项目的tar gz包地址 publish
命令： npm publish  [&amp;ndash;tag ]
npm publish https://codeload.github.com/materliu/grunt-localhosts/legacy.tar.gz/master &amp;ndash;tag 0.0.1
后边 &amp;ndash;tag 指定你要覆盖的版本， 不跟的话就是覆盖最新版
如果项目没有在github提交，publish命令为：npm publish  [&amp;ndash;tag ]
简单的方式 直接进入当前 npm modules 项目所在目录 npm publish 搞定
注意点： 没有必要把你的npm用到的node_modules也上传到你的github上， 最后用户安装你的npm的时候， 是根据你的package.json文件中的 dependencies 里边指定的项来自动帮你安装的， 而不是根据你github里边上传了什么node_modules来的。</description>
    </item>
    
    <item>
      <title>url长度限制</title>
      <link>https://materliu.github.io/blog/posts/2014-05-26-url-length-limitation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-05-26-url-length-limitation/</guid>
      <description>url长度限制 由于之前的一个web项目中，要用get方法去获取数据，但结果时常报错，经过仔细排查才发现原来url长度超过了限制，通过缩短url和发送多次请求的方法解决了该问题，之后在网上查了些资料，发现这个问题还是内藏玄机，要比自己想的复杂。
首先，其实http 1.1 协议中对url的长度是不受限制的，协议原文：
The HTTP protocol does not place any a priori limit on the length of a URI. Servers MUST be able to handle the URI of any resource they serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs. A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.</description>
    </item>
    
    <item>
      <title>web无障碍化整理贴</title>
      <link>https://materliu.github.io/blog/posts/2014-03-30-web-accessibility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-03-30-web-accessibility/</guid>
      <description>国内读屏软件争渡
国外读屏软件NVDA
360浏览器插件开发页面提供的无障碍知识
alloyteam博客文章1
alloyteam博客文章2
朋友网的经验小结
讲解很多无障碍化实践的博客
QQ空间、腾讯网无障碍化的一些规范1
QQ空间、腾讯网无障碍化的一些规范2
QQ空间、腾讯网无障碍化的一些规范3
无障碍访问组件
Web Accessibility Checklist
无障碍化的坑
* 在chrome32中，设置title属性的按钮读屏软件会读出，但到了客户端里面就不行！此时必须设置dom节点的文本，没法设置的话考虑用aria-label属性（争渡读屏）  个人经验总结 以下都是QQ5.3客户端内的表现，使用的chrome29同样的webkit内核
  争渡 对于a 标签 都能通过tab聚焦上去，读法是： a内容 + href里边的内容 如果href是### 那么读屏软件读的就是当前网页地址
  争渡 对于 button 标签， 都能通过tab聚焦上去， 读法是：aria-label + “按下按钮&amp;quot; + title 没有aria-label的情况： button内内容 + &amp;ldquo;按下按钮&amp;rdquo; + title
  </description>
    </item>
    
    <item>
      <title>window.onError不是万能的</title>
      <link>https://materliu.github.io/blog/posts/2014-03-26-window.onerror%E4%B8%8D%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-03-26-window.onerror%E4%B8%8D%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84/</guid>
      <description>window.onError window.onerror是万能的吗？被设计成捕获一切运行时异常，事实告诉我们捕获是可以的， 但是在webkit内核下存在跨域js资源产生的错误无法定位 高居badJS排行榜的就包括这个问题
 Script Error._|_0。  参考这篇文章 http://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox</description>
    </item>
    
    <item>
      <title>编码知识梳理</title>
      <link>https://materliu.github.io/blog/posts/2014-04-22-charset-utf-ascii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-22-charset-utf-ascii/</guid>
      <description>编码知识梳理 一直以来我对编码知识都倍感疑惑。借着这次整理书库的机会，把之前 joltwang(⺩王辉) 分享的编码知识ppt翻了出来，特此重新梳理一下
首先要搞明白一个问题， 那就是什么是字符 abcd算是 √®∑ø当然也算是 emoij表情符号也算是 夏でも底に冷たさをもつ青いそら 也算是
那什么是字符集呢 显而易见把具有相同特征的字符归纳整理到一个集合中就形成了字符集
那只有0，1表示的计算机是如何存储这些字符信息的呢？ 这就涉及到了编码
 字符编码的要素
  首先要规定占用存储，也就是说一个字符需要几个字节来表示
  生成编码规则下的编码表，也就是规定字符与字节序列间的一一对应关系
    ASCII (American Standard Code for Information Interchange)
  是基于拉丁字母的一套字符编码，占用一个字节，使用了一个字节中的7位，定义了128个字符，其中33个非显示字符，96个可显示字符
我们知道，在计算机内部，所有的信息最终都表示成一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到11111111
ASCII编码就是把英语字符和二进制位之间的关系，做了统一规定。比如空格是32（二进制 00100000）， 大写字母A是65（二进制是 01000001）。ACSII只使用了后7位bit，每个字节的第一位bit统一为0。 空格当然算是可显示字符了，至于不可显示字符，多是一些陈废的操控文字的控制字符，但在DOS模式下可显示出一些诸如笑脸，扑克牌花式等符号。
ISO8859实际上是一种字符集标准——拉丁字符集,各个子集都有自 己的字符编码,共有14种字符编码。比如说iso-8859-1 扩展位放置的时德文字符， iso-8859-7 扩展位放的是希腊字符，这个标准存在的问题就是子集扩展部分互不兼容，只有拉丁字符部分相互兼容。
英文字符集: 26个字母;
简体字符集: 85000个,常用汉字:7000个。
简体字符的编码表远大于拉丁字符的编码表。
所以我们有了GB系列的编码
说说GB2312
借鉴 ISO8859 的编码思想,兼容ASCII,以两个字节为单位存储进行扩展。
两个字节就有72 * 94 = 6768种可能,也就是可以表示 6768 种汉 字,GB2312实际收录6763个汉字,占常用汉字的99%。
存在的问题:很多汉字无法打印出来,比如朱镕基的“镕”,只能使用(金 +容)、(金容)、(左金右容)等来表示。
诸如此类的， 繁体中文有了 big5 编码， 韩文有了EUC-KR编码， 日文有了SJIS编码</description>
    </item>
    
    <item>
      <title>机器安装huginn</title>
      <link>https://materliu.github.io/blog/posts/2014-12-17-huginn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-12-17-huginn/</guid>
      <description>机器如何安装huginn https://github.com/cantino/huginn huginn 是一个类似于网络监听器的东西， 可以监听任何网络上的变更， 一旦接收到这些变更则及时通知给你写的第二级程序， 这个时候你的二级程序就可以随心所欲的去干一些事情了。
安装步骤略复杂， 所以这里记录一下。
 git， ruby 环境准备好。 apt-get install git 安装rvm https://rvm.io/rvm/install 注意按照安装指南来 如果出现 rvm is not function 的提示参见：https://ruby-china.org/topics/3705 利用rvm 安装ruby的版本 https://ruby-china.org/wiki/rvm-guide 推荐使用ruby1.9.3 安装mysql, root 1234asdf 按照huginn页面的说明， 拷贝 .env 修改 其中内容 安装 rake，bundle apt-get install rake apt-get install bundle 更新一下gem，sudo gem install rubygems-update sudo update_rubygems (也可以不更新) bundle install, 如果报mysql2的错误， 需要先运行： sudo apt-get install libmysqlclient-dev 首先要修改的就是 APP_SECRET_TOKEN 字段, 运行 rake secret 修改完APP_SECRET_TOKEN， 在.env 中添加gmail 邮箱 按照huginn的指南执行几步指令， 到foreman start 先不执行 foreman start 进入mysql mysql -u root -p 使用数据库 use huginn_development; source ~/data/huginn/huginn.</description>
    </item>
    
    <item>
      <title>如何正确的书写网站底部版权</title>
      <link>https://materliu.github.io/blog/posts/2014-09-02-write-right-copyright/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-09-02-write-right-copyright/</guid>
      <description>如何正确的书写网站底部版权 页面底部版权信息 完整的版权信息需要包含以下几个部分：1.构建程序版权信息；（必须）2.界面设计信息；3.二次开发信息；4.站点版权信息。
 构建程序版权信息  也就是我们比较常见的“Powered By 阿里巴巴”（例如：Powered By Materliu），这里需要包含站点所构建程序的相关信息，当然您也可以包含一些附加信息，例如程序的版本号、语言类型等（例如：Powered By 阿里巴巴v1.0）。
这里的程序信息需要包含链接，一般直接链接到应用程序官方网站即可，例如：http://www.alibaba.com，同时我们建议链接的方式采用新窗口中打开。
界面设计信息  包含模板界面设计的信息，也就是“Design By 模板设计师”，这里包含界面模板设计师的相关信息。例如：Design By Materliu。同版权信息一样，模板设计师也可以加上链接。
二次开发信息  如果程序涉及到二次开发，可以在模板底部版权中选择加入二次开发信息，也就是“ReDevelop By 二次开发信息”（例如：ReDevelop By Materliu官方团队）。
如果是设计和开发都有同一组织或个人完成，可以写成“Design And ReDevelop By 组织/个人信息”
站点版权信息  一般是站点是归属公司团体或者个人，也就是“CopyRight xxxx-xxxx 公司/团队”（例如：CopyRight 2004-2014 Tencent INC.），这里2004是站点或者团体拥有版权开始日期，2014一般是当前日期。如果是个人站点可以直接采用CopyRight xxxx-xxxx XXX.COM的方式来代替。</description>
    </item>
    
    <item>
      <title>软件版本定义规则</title>
      <link>https://materliu.github.io/blog/posts/2014-04-20-software-version-definition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-04-20-software-version-definition/</guid>
      <description>软件版本定义规则 基本规则
顾名思义，语义化的版本就是让版本号更具语义化，可以传达出关于软件本身的一些重要信息而不只是简单的一串数字。
版本格式：主版本号.次版本号.修订号，版本号递增规则如下：
主版本号：当你做了不兼容的API 修改 次版本号：当你做了向下兼容的功能性新增 修订号：当你做了向下兼容的问题修正 先行版（预览版）版本号及版本编译信息可以加到&amp;quot;主版本号.次版本号.修订号&amp;quot;的后面，作为延伸。
具体规范
具体详尽的规范可以参见其官网，当然也可以访问中文版本。这里简单总结一下。
版本号是以点隔开的形式&amp;rsquo;X.Y.Z&amp;rsquo; 且XYZ为正整数，数字前面不加0， 也就是说v0.1.0不能写成v0.10.0 一般软件开发过程中以0.1.0 版本开始，开发过程中不断增加新功能，则增加次版本号比如变成0.2.0，然后期间的问题及bug修复体现在修订号上，比如版本号变成0.1.12。这一阶段的版本视为不稳定版本，一般也未对外发布 主版本号表示正式版的形成，也即如果你开发的是供大家使用的软件或插件，那就标致本软件公共API的形成，比如新浪微博API v1.0.0发布，大家就可以在自己网站上调用了，这是个正式而稳定的版本。所以这里有个规定，版本一旦发布，不允许对软件做任何修改。任何改过之后的代码都应标记新的版本号在下次发布中体现 主版本号的增加可以是次版本号以有修订号增加到一定数量后的结果，也可以是有不兼容旧版的新功能或API加入的结果，并且主版本增加后次版本号和修订号归零 次版本号表示有兼容旧版本的功能或API增加，而修订号表示bug修复并且这种修复一般是对代码结果不正确的修复而且一定是兼容旧版本的，如果你修复bug越改越大结果不兼容旧版本了，则需要增加主版本号 其他信息比如预览版，先行版或者软件编译信息可以跟随在修订号之后。示例：1.0.0-alpha+001、1.0.0+20130313144700、 1.0.0-beta+exp.sha.5114f85
外文网站参考资料</description>
    </item>
    
    <item>
      <title>写入cookie的时候对path的要求</title>
      <link>https://materliu.github.io/blog/posts/2014-11-09-cookie-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://materliu.github.io/blog/posts/2014-11-09-cookie-path/</guid>
      <description>写入cookie的时候对path的要求  http://materliu.test.org/cookie-path/cookie-a.html 页面向路径 /cookie-pathB/ 写入cookie内容， 发现无法写入。 http://materliu.test.org/cookie-path/cookie-a.html 页面向路径 /cookie-path/ 写入cookie内容， 发现写入成功。 在控制台输出 document.cookie cookie内没有path内容，值为写入内容&amp;quot;pathA=test&amp;quot;。 http://materliu.test.org/cookie-path/cookie-a.html 页面向路径 / 写入cookie内容， 发现写入成功。 在控制台输出 document.cookie cookie内没有path内容，值为写入内容&amp;quot;pathA=test&amp;quot;。 http://materliu.test.org/cookie-path/cookie-a.html 页面向读取写入在路径 / 下的cookie内容， 发现读取成功。 http://materliu.test.org/cookie-path/cookie-a.html 页面向读取写入在路径 /cookie-path/ 下的cookie内容， 发现读取成功。 http://materliu.test.org/cookie-path/cookie-a.html 页面向读取写入在路径 /cookie-pathB/ 下的cookie内容， 发现读取失败 http://materliu.test.org/cookie-path/cookie-a.html 页面向读取写入在路径 /cookie-path/cookie-sec-path 下的cookie内容， 发现读取失败  结论： 页面可以读取跟自己相同或者上一级path的cookie， 无法读取自己路径，或者不同路径的cookie。
补充知识： 屈光宇文章
  服务器在使用 set-cookie Header的时候，可以设置HttpOnly， JS不能读取HttpOnly的cookie。
  如果cookie带有secure字段， 表示这个cookie仅在https环境下才能使用。
  host-only-flag：在Cookie中不包含Domain属性，或者Domain属性为空，或者Domain属性不合法（不等于页面url中的Domain部分、也不是页面Domain的大域）时为true。此时，我们把这个Cookie称之为HostOnly Cookie；
 那么host-only-flag如果为true会怎样呢？获取Cookie时，首先要检查Domain匹配性，其次才检查path、secure、httponly等属性的匹配性。如果host-only-flag为true时，只有当前域名与该Cookie的Domain属性完全相等才可以进入后续流程；host-only-flag为false时，符合域规则（domain-matches）的域名都可以进入后续流程。    举个例子，host-only-flag为true时，Domain属性为example.com的Cookie只有在example.com才有可能获取到；host-only-flag为false时，Domain属性为example.com的Cookie，在example.com、www.example.com、sub.example.com等等都可能获取到。
设置Cookie时，Domain属性值如果是.a.com，前面的.会被去掉，变成a.com（rfc6265第5.2.3节）； 对于name、path和domain均相同的Cookie，后面的覆盖前面的（rfc6265第5.</description>
    </item>
    
  </channel>
</rss>
