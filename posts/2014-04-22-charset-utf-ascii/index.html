<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编码知识梳理 | 知了</title><meta name=keywords content><meta name=description content="编码知识梳理 一直以来我对编码知识都倍感疑惑。借着这次整理书库的机会，把之前 joltwang(⺩王辉) 分享的编码知识ppt翻了出来，特此重新梳理一下
首先要搞明白一个问题， 那就是什么是字符 abcd算是 √®∑ø当然也算是 emoij表情符号也算是 夏でも底に冷たさをもつ青いそら 也算是
那什么是字符集呢 显而易见把具有相同特征的字符归纳整理到一个集合中就形成了字符集
那只有0，1表示的计算机是如何存储这些字符信息的呢？ 这就涉及到了编码
 字符编码的要素
  首先要规定占用存储，也就是说一个字符需要几个字节来表示
  生成编码规则下的编码表，也就是规定字符与字节序列间的一一对应关系
    ASCII (American Standard Code for Information Interchange)
  是基于拉丁字母的一套字符编码，占用一个字节，使用了一个字节中的7位，定义了128个字符，其中33个非显示字符，96个可显示字符
我们知道，在计算机内部，所有的信息最终都表示成一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到11111111
ASCII编码就是把英语字符和二进制位之间的关系，做了统一规定。比如空格是32（二进制 00100000）， 大写字母A是65（二进制是 01000001）。ACSII只使用了后7位bit，每个字节的第一位bit统一为0。 空格当然算是可显示字符了，至于不可显示字符，多是一些陈废的操控文字的控制字符，但在DOS模式下可显示出一些诸如笑脸，扑克牌花式等符号。
ISO8859实际上是一种字符集标准——拉丁字符集,各个子集都有自 己的字符编码,共有14种字符编码。比如说iso-8859-1 扩展位放置的时德文字符， iso-8859-7 扩展位放的是希腊字符，这个标准存在的问题就是子集扩展部分互不兼容，只有拉丁字符部分相互兼容。
英文字符集: 26个字母;
简体字符集: 85000个,常用汉字:7000个。
简体字符的编码表远大于拉丁字符的编码表。
所以我们有了GB系列的编码
说说GB2312
借鉴 ISO8859 的编码思想,兼容ASCII,以两个字节为单位存储进行扩展。
两个字节就有72 * 94 = 6768种可能,也就是可以表示 6768 种汉 字,GB2312实际收录6763个汉字,占常用汉字的99%。
存在的问题:很多汉字无法打印出来,比如朱镕基的“镕”,只能使用(金 +容)、(金容)、(左金右容)等来表示。
诸如此类的， 繁体中文有了 big5 编码， 韩文有了EUC-KR编码， 日文有了SJIS编码"><meta name=author content="Theme PaperMod"><link rel=canonical href=https://materliu.github.io/blog/posts/2014-04-22-charset-utf-ascii/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://materliu.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://materliu.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://materliu.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://materliu.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://materliu.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://materliu.github.io/blog/posts/2014-04-22-charset-utf-ascii/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link href=/blog/css/nucleus.css?1663571234 rel=stylesheet><link href=/blog/css/fontawesome-all.min.css?1663571234 rel=stylesheet><link href=/blog/css/hybrid.css?1663571234 rel=stylesheet><link href=/blog/css/featherlight.min.css?1663571234 rel=stylesheet><link href=/blog/css/perfect-scrollbar.min.css?1663571234 rel=stylesheet><link href=/blog/css/auto-complete.css?1663571234 rel=stylesheet><link href=/blog/css/atom-one-dark-reasonable.css?1663571234 rel=stylesheet><link href=/blog/css/theme.css?1663571234 rel=stylesheet><link href=/blog/css/tabs.css?1663571234 rel=stylesheet><link href=/blog/css/hugo-theme.css?1663571234 rel=stylesheet><style>ul,ol,h2{margin:0}</style><script src=/blog/js/jquery-3.3.1.min.js?1663571234></script><meta property="og:title" content="编码知识梳理"><meta property="og:description" content="编码知识梳理 一直以来我对编码知识都倍感疑惑。借着这次整理书库的机会，把之前 joltwang(⺩王辉) 分享的编码知识ppt翻了出来，特此重新梳理一下
首先要搞明白一个问题， 那就是什么是字符 abcd算是 √®∑ø当然也算是 emoij表情符号也算是 夏でも底に冷たさをもつ青いそら 也算是
那什么是字符集呢 显而易见把具有相同特征的字符归纳整理到一个集合中就形成了字符集
那只有0，1表示的计算机是如何存储这些字符信息的呢？ 这就涉及到了编码
 字符编码的要素
  首先要规定占用存储，也就是说一个字符需要几个字节来表示
  生成编码规则下的编码表，也就是规定字符与字节序列间的一一对应关系
    ASCII (American Standard Code for Information Interchange)
  是基于拉丁字母的一套字符编码，占用一个字节，使用了一个字节中的7位，定义了128个字符，其中33个非显示字符，96个可显示字符
我们知道，在计算机内部，所有的信息最终都表示成一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到11111111
ASCII编码就是把英语字符和二进制位之间的关系，做了统一规定。比如空格是32（二进制 00100000）， 大写字母A是65（二进制是 01000001）。ACSII只使用了后7位bit，每个字节的第一位bit统一为0。 空格当然算是可显示字符了，至于不可显示字符，多是一些陈废的操控文字的控制字符，但在DOS模式下可显示出一些诸如笑脸，扑克牌花式等符号。
ISO8859实际上是一种字符集标准——拉丁字符集,各个子集都有自 己的字符编码,共有14种字符编码。比如说iso-8859-1 扩展位放置的时德文字符， iso-8859-7 扩展位放的是希腊字符，这个标准存在的问题就是子集扩展部分互不兼容，只有拉丁字符部分相互兼容。
英文字符集: 26个字母;
简体字符集: 85000个,常用汉字:7000个。
简体字符的编码表远大于拉丁字符的编码表。
所以我们有了GB系列的编码
说说GB2312
借鉴 ISO8859 的编码思想,兼容ASCII,以两个字节为单位存储进行扩展。
两个字节就有72 * 94 = 6768种可能,也就是可以表示 6768 种汉 字,GB2312实际收录6763个汉字,占常用汉字的99%。
存在的问题:很多汉字无法打印出来,比如朱镕基的“镕”,只能使用(金 +容)、(金容)、(左金右容)等来表示。
诸如此类的， 繁体中文有了 big5 编码， 韩文有了EUC-KR编码， 日文有了SJIS编码"><meta property="og:type" content="article"><meta property="og:url" content="https://materliu.github.io/blog/posts/2014-04-22-charset-utf-ascii/"><meta property="og:image" content="https://materliu.github.io/blog/papermod-cover.png"><meta property="article:section" content="posts"><meta property="og:site_name" content="知了"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://materliu.github.io/blog/papermod-cover.png"><meta name=twitter:title content="编码知识梳理"><meta name=twitter:description content="编码知识梳理 一直以来我对编码知识都倍感疑惑。借着这次整理书库的机会，把之前 joltwang(⺩王辉) 分享的编码知识ppt翻了出来，特此重新梳理一下
首先要搞明白一个问题， 那就是什么是字符 abcd算是 √®∑ø当然也算是 emoij表情符号也算是 夏でも底に冷たさをもつ青いそら 也算是
那什么是字符集呢 显而易见把具有相同特征的字符归纳整理到一个集合中就形成了字符集
那只有0，1表示的计算机是如何存储这些字符信息的呢？ 这就涉及到了编码
 字符编码的要素
  首先要规定占用存储，也就是说一个字符需要几个字节来表示
  生成编码规则下的编码表，也就是规定字符与字节序列间的一一对应关系
    ASCII (American Standard Code for Information Interchange)
  是基于拉丁字母的一套字符编码，占用一个字节，使用了一个字节中的7位，定义了128个字符，其中33个非显示字符，96个可显示字符
我们知道，在计算机内部，所有的信息最终都表示成一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到11111111
ASCII编码就是把英语字符和二进制位之间的关系，做了统一规定。比如空格是32（二进制 00100000）， 大写字母A是65（二进制是 01000001）。ACSII只使用了后7位bit，每个字节的第一位bit统一为0。 空格当然算是可显示字符了，至于不可显示字符，多是一些陈废的操控文字的控制字符，但在DOS模式下可显示出一些诸如笑脸，扑克牌花式等符号。
ISO8859实际上是一种字符集标准——拉丁字符集,各个子集都有自 己的字符编码,共有14种字符编码。比如说iso-8859-1 扩展位放置的时德文字符， iso-8859-7 扩展位放的是希腊字符，这个标准存在的问题就是子集扩展部分互不兼容，只有拉丁字符部分相互兼容。
英文字符集: 26个字母;
简体字符集: 85000个,常用汉字:7000个。
简体字符的编码表远大于拉丁字符的编码表。
所以我们有了GB系列的编码
说说GB2312
借鉴 ISO8859 的编码思想,兼容ASCII,以两个字节为单位存储进行扩展。
两个字节就有72 * 94 = 6768种可能,也就是可以表示 6768 种汉 字,GB2312实际收录6763个汉字,占常用汉字的99%。
存在的问题:很多汉字无法打印出来,比如朱镕基的“镕”,只能使用(金 +容)、(金容)、(左金右容)等来表示。
诸如此类的， 繁体中文有了 big5 编码， 韩文有了EUC-KR编码， 日文有了SJIS编码"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://materliu.github.io/blog/posts/"},{"@type":"ListItem","position":3,"name":"编码知识梳理","item":"https://materliu.github.io/blog/posts/2014-04-22-charset-utf-ascii/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"编码知识梳理","name":"编码知识梳理","description":"编码知识梳理 一直以来我对编码知识都倍感疑惑。借着这次整理书库的机会，把之前 joltwang(⺩王辉) 分享的编码知识ppt翻了出来，特此重新梳理一下\n首先要搞明白一个问题， 那就是什么是字符 abcd算是 √®∑ø当然也算是 emoij表情符号也算是 夏でも底に冷たさをもつ青いそら 也算是\n那什么是字符集呢 显而易见把具有相同特征的字符归纳整理到一个集合中就形成了字符集\n那只有0，1表示的计算机是如何存储这些字符信息的呢？ 这就涉及到了编码\n 字符编码的要素\n  首先要规定占用存储，也就是说一个字符需要几个字节来表示\n  生成编码规则下的编码表，也就是规定字符与字节序列间的一一对应关系\n    ASCII (American Standard Code for Information Interchange)\n  是基于拉丁字母的一套字符编码，占用一个字节，使用了一个字节中的7位，定义了128个字符，其中33个非显示字符，96个可显示字符\n我们知道，在计算机内部，所有的信息最终都表示成一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到11111111\nASCII编码就是把英语字符和二进制位之间的关系，做了统一规定。比如空格是32（二进制 00100000）， 大写字母A是65（二进制是 01000001）。ACSII只使用了后7位bit，每个字节的第一位bit统一为0。 空格当然算是可显示字符了，至于不可显示字符，多是一些陈废的操控文字的控制字符，但在DOS模式下可显示出一些诸如笑脸，扑克牌花式等符号。\nISO8859实际上是一种字符集标准——拉丁字符集,各个子集都有自 己的字符编码,共有14种字符编码。比如说iso-8859-1 扩展位放置的时德文字符， iso-8859-7 扩展位放的是希腊字符，这个标准存在的问题就是子集扩展部分互不兼容，只有拉丁字符部分相互兼容。\n英文字符集: 26个字母;\n简体字符集: 85000个,常用汉字:7000个。\n简体字符的编码表远大于拉丁字符的编码表。\n所以我们有了GB系列的编码\n说说GB2312\n借鉴 ISO8859 的编码思想,兼容ASCII,以两个字节为单位存储进行扩展。\n两个字节就有72 * 94 = 6768种可能,也就是可以表示 6768 种汉 字,GB2312实际收录6763个汉字,占常用汉字的99%。\n存在的问题:很多汉字无法打印出来,比如朱镕基的“镕”,只能使用(金 +容)、(金容)、(左金右容)等来表示。\n诸如此类的， 繁体中文有了 big5 编码， 韩文有了EUC-KR编码， 日文有了SJIS编码","keywords":[],"articleBody":"编码知识梳理 一直以来我对编码知识都倍感疑惑。借着这次整理书库的机会，把之前 joltwang(⺩王辉) 分享的编码知识ppt翻了出来，特此重新梳理一下\n首先要搞明白一个问题， 那就是什么是字符 abcd算是 √®∑ø当然也算是 emoij表情符号也算是 夏でも底に冷たさをもつ青いそら 也算是\n那什么是字符集呢 显而易见把具有相同特征的字符归纳整理到一个集合中就形成了字符集\n那只有0，1表示的计算机是如何存储这些字符信息的呢？ 这就涉及到了编码\n 字符编码的要素\n  首先要规定占用存储，也就是说一个字符需要几个字节来表示\n  生成编码规则下的编码表，也就是规定字符与字节序列间的一一对应关系\n    ASCII (American Standard Code for Information Interchange)\n  是基于拉丁字母的一套字符编码，占用一个字节，使用了一个字节中的7位，定义了128个字符，其中33个非显示字符，96个可显示字符\n我们知道，在计算机内部，所有的信息最终都表示成一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到11111111\nASCII编码就是把英语字符和二进制位之间的关系，做了统一规定。比如空格是32（二进制 00100000）， 大写字母A是65（二进制是 01000001）。ACSII只使用了后7位bit，每个字节的第一位bit统一为0。 空格当然算是可显示字符了，至于不可显示字符，多是一些陈废的操控文字的控制字符，但在DOS模式下可显示出一些诸如笑脸，扑克牌花式等符号。\nISO8859实际上是一种字符集标准——拉丁字符集,各个子集都有自 己的字符编码,共有14种字符编码。比如说iso-8859-1 扩展位放置的时德文字符， iso-8859-7 扩展位放的是希腊字符，这个标准存在的问题就是子集扩展部分互不兼容，只有拉丁字符部分相互兼容。\n英文字符集: 26个字母;\n简体字符集: 85000个,常用汉字:7000个。\n简体字符的编码表远大于拉丁字符的编码表。\n所以我们有了GB系列的编码\n说说GB2312\n借鉴 ISO8859 的编码思想,兼容ASCII,以两个字节为单位存储进行扩展。\n两个字节就有72 * 94 = 6768种可能,也就是可以表示 6768 种汉 字,GB2312实际收录6763个汉字,占常用汉字的99%。\n存在的问题:很多汉字无法打印出来,比如朱镕基的“镕”,只能使用(金 +容)、(金容)、(左金右容)等来表示。\n诸如此类的， 繁体中文有了 big5 编码， 韩文有了EUC-KR编码， 日文有了SJIS编码\n这样依然存在问题， 这些编码集相互不兼容。\n微软在发行windows95的时候发现了中文简繁体不能共存的问题， 所以提出了gbk编码，\nGBK(kuozhan 扩展)是对GB2312的扩展, 最早实现于Windows 95简体中文版, 双字节存储。\n包含了 gb2312 和 big5 + 少数民族 + 日韩东亚文字\n后来我们国家又提出了 gb18030 编码标准， 被称为国标码 主要工作是对多名族语言的补充,采用多字节编码,每个字可以由1个、2个或4个字 节组成。\ngk18030 包含了gbk以及更丰富的少数民族文字 藏文，满文等\n但是gb18030 仍然解决不了国际化的问题。\n这时候就需要诞生一个国际化的编码标准，首先出现的是一个字符集那就是unicode字符集。\n需要注意的unicode只是一个字符集， 它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n比如，汉子“严”的unicode表示是4E25，转换成二进制足足有15位\n100111000100101，也就是说这个负号的表示至少需要2个字节。表示其他更大的符号，可能需要3个或者4个字节，甚至更多。\n这里就有两个严重的问题：\n  如何才能区分unicode和ascii？ 计算机怎么知道三个字节表示一个符号而不是分别表示三个符号呢？\n  我们已经知道英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或者四个字节表示，那么每个英文字母前都必须有两到三个字节全部为0，这对于存储来说是极大的浪费，文本文件的大小会因此大出两到三倍，这是无法接受的。\n  所以就有了下边的结果：\n  出现了unicode的多种存储方式。也就是说有许多种不同的二进制格式，可以用来表示unicode字符集\n  unicode在很长一段时间内无法推广，直到互联网的出现\n  下边就来说一说各种编码方式:\n  UTF: unicode transformation format\n  utf-8: 可变长的\n  utf-16: 大部分是2个字节\n  utf-32: 4个字节\n  在Unicode中：汉字“字”对应的数字是23383（十进制），十六进制表示为5B57。在Unicode中，我们有很多方式将数字23383表示成程序中的数据，包括：UTF-8、UTF-16、UTF-32。UTF是“UCS Transformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。例如，“汉字”对应的数字是0x6c49和0x5b57，而编码的程序数据是：\nchardata_utf8[]={0xE6,0xB1,0x89,0xE5,0xAD,0x97};//UTF-8编码\nchar16_tdata_utf16[]={0x6C49,0x5B57};//UTF-16编码\nchar32_tdata_utf32[]={0x00006C49,0x00005B57};//UTF-32编码\n这里用char、char16_t、char32_t分别表示无符号8位整数，无符号16位整数和无符号32位整数。UTF-8、UTF-16、UTF-32分别以char、char16_t、char32_t作为编码单位。（注： char16_t 和 char32_t 是 C++ 11 标准新增的关键字。如果你的编译器不支持 C++ 11 标准，请改用 unsigned short 和 unsigned long。）“汉字”的UTF-8编码需要6个字节。“汉字”的UTF-16编码需要两个char16_t，大小是4个字节。“汉字”的UTF-32编码需要两个char32_t，大小是8个字节。根据字节序的不同，UTF-16可以被实现为UTF-16LE或UTF-16BE，UTF-32可以被实现为UTF-32LE或UTF-32BE。下面介绍UTF-8、UTF-16、UTF-32、字节序和BOM。[1]\n  utf-8\n  与ASCII兼容,这使得原来的软件无须或只须做少部份修改,即 可继续使用。 因此,它逐渐成为电子邮件、网页及其他存储或传送文字的应用 中,优先采用的编码。\nUTF-8文件的Unicode签名BOM(Byte Order Mark)问题\n近日在调测一个UTF8编码的中文Zen Cart网站时遇到一件怪事，网页显示文字正常，用ie的察看源文件（记事本打开）却发现乱码，firefox没有这个问题。经在网上多方查证和多次测试，解决了这个问题，其实是UTF-8文件的Unicode签名BOM(Byte Order Mark)问题。\nBOM(Byte Order Mark)，是UTF编码方案里用于标识编码的标准标记，在UTF-16里本来是FF FE，变成UTF-8就成了EF BB BF。这个标记是可选的，因为UTF8字节没有顺序，所以它可以被用来检测一个字节流是否是UTF-8编码的。微软做这种检测，但有些软件不做这种检测，而把它当作正常字符处理。\n微软在自己的UTF-8格式的文本文件之前加上了EF BB BF三个字节, windows上面的notepad等程序就是根据这三个字节来确定一个文本文件是ASCII的还是UTF-8的, 然而这个只是微软暗自作的标记, 其它平台上并没有对UTF-8文本文件做个这样的标记。\n也就是说一个UTF-8文件可能有BOM，也可能没有BOM，那么怎么区分呢？三种方法。1，用UltraEdit-32打开文件，切换到十六进制编辑模式，察看文件头部是否有EF BB BF。2，用Dreamweaver打开，察看页面属性，看“包括Unicode签名BOM”前面是否有个勾。3，用Windows的记事本打开，选择 “另存为”，看文件的默认编码是UTF-8还是ANSI，如果是ANSI则不带BOM。\n我找到Zen Cart的模版文件中的html_header.php，发现文件果然不带BOM，用UltraEdit-32另存为的方式加上BOM后，再上传html_header.php，一切正常。\n注意用Convertz把gb2312文件转换成UTF-8文件时，默认设置是不带BOM的。不带BOM可能出现上述乱码问题，但是带 BOM，对于php的include文件要小心，会在php字节流前面多出EF BB BF，提前输出到显示器有可能会带来程序错误。一个解决方案是凡是被include的文件都保存为ANSI，主文件可以是UTF-8。要想把一个文件去掉 BOM，使用UlterEdit打开, 切换到十六进制编辑模式，把最前面三个字节(就是那该死的 EF BB BF)替换为20，保存（注意关闭保存时自动备份的功能），再切换到默认编辑模式，把最前面的三个空格去掉就可以了。\n另外还学到一些编码的小知识：所谓的unicode保存的文件实际上是utf-16，只不过恰好跟unicode的码相同而已,但在概念上unicode与utf是两回事，unicode是内存编码表示方案，而utf是如何保存和传输unicode的方案。utf-16还分高位在前 (LE)和高位在后(BE)两种。官方的utf编码还有utf-32，也分LE和BE。非unicode官方的utf编码还有utf-7，主要用于邮件传输。utf-8的单字节部分是和iso-8859-1兼容的，这主要是一些旧的系统和库函数不能正确处理utf-16而被迫出来的，而且对英语字符来说，也节省保存的文件空间（以非英语字符浪费空间为代价）。在iso-8859-1的时候，utf8和iso-8859-1都是用一个字节表示的，当表示其它字符的时候，utf-8会使用两个或三个字节。\nThe UTF-8 BOM is a sequence of bytes (EF BB BF) that allows the reader to identify the file as an UTF-8 file.\nNormally, the BOM is used to signal the endianness of the encoding, but since endianness is irrelevant to UTF-8, the BOM is unnecessary.\nAccording to the Unicode standard, the BOM for UTF-8 files is not recommended:\nShort answer: In UTF-8, a BOM is encoded as the bytes EF BB BF at the beginning of the file.\nLong answer:\nOriginally, it was expected that Unicode would be encoded in UTF-16/UCS-2. The BOM was designed for this encoding form. When you have 2-byte code units, it’s necessary to indicate which order those two bytes are in, and a common convention for doing this is to include the character U+FEFF as a “Byte Order Mark” at the beginning of the data. The character U+FFFE is permanently unassigned so that its presence can be used to detect the wrong byte order.\nUTF-8 has the same byte order regardless of platform endianness, so a byte order mark isn’t needed. However, it may occur (as the byte sequence EF BB FF) in data that was converted to UTF-8 from UTF-16, or as a “signature” to indicate that the data is UTF-8.\nstackoverflow上的讨论，知识更多更全\n几种编码格式的bom值\nUTF-8\nEF BB BF\nUTF-16\nFF FE\nUTF-16 big endian\nFE FF\nUTF-32\nFF FE 00 00\nUTF-32 big endian\n00 00 FE FF\n  UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：\nUnicode编码(十六进制)　 UTF-8 字节流(二进制) 000000 - 00007F 0xxxxxxx 000080 - 0007FF 110xxxxx 10xxxxxx 000800 - 00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000 - 10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。\n例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。\n例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。\n移动比联通强的原因是记事本无法显示“联通”?\n流言：\n 在Windows操作系统中使用记事本新建一个文本文件，在文件里面写入“联通”两个字并保存。当再次打开这个文本文件时候，在记事本中看到得却不是刚刚输入的“联通”，而是乱码。这就是移动比联通强的原因！\n 粉碎： 出现上述问题本质上是：GB2312与UTF-8编码冲突所致。首先普及一下编码常识： ASCII的霸权： 起初，是一些人想用8个晶体的亮灭表示世间万物，于是产生了“编码”，最早是美国人发明了ASCII字符集(American Standard Code for Information Interchange，美国信息互换标准代码）用来存储英文字符，一个字节8位，可以表示2^8=256个符号，其中0~32特殊用途（0x20以下）；32~127 存储 英文；128~255为扩展字符集； GB2312的来历： 中国人想用电脑读写汉字，256个字符不够用怎么办？于是果断舍弃127之后没用的字符，并且在ASCII的基础上规定如果一个字符小于127则表示原字符，即所谓的半角字符，如果连续两个字符大于127则表示一个汉字，即全角字符。这就是GB2312，它实际是ASCII的中文扩展。 都来又有GBK，GB18030，都是对汉字字符集的扩充。 UNICODE的大一统： 一个叫 ISO （国际标谁化组织）的国际组织决定用16位来表示地球上所有文字，于是产生传说中的\"Universal Multiple-Octet Coded Character Set\"，简称 UCS, 俗称 “UNICODE”。它规定两个字节为一个字符，英文高8位都是0，但问题是GBK 与UNICODE 在汉字内码编码完全不同。这为谣言埋下了伏笔…. UTF8的传输： 互联网上70%的内容是英文，而UNICODE英文高8位为0，如果采用UNICODE传输无疑造成空间浪费，于是产生UTF8即每次8个位传输数据，当然还有UTF16，UTF32，都是按一定规则转化后的编码形式。\n这样就可以解释记事本不能显示的问题了，实际上，“联通”这两个字符的GBK编码具有UTF-8编码的特征，记事本犯下的错误正是将GBK编码存放的记录有“联通”两个字符的文件误认为UTF-8编码的文件。\n细节（有兴趣看下）： UTF-8编码采用1-3个字节对字符进行编码，编码字节数与字符的Unicode编码值有严格的对应关系，让我们回忆下UTF-8编码和Unicode的对应关系吧。\nUnicode编码值 UTF-8编码结构 \\u0001 - \\u007E 0XXXXXXX \\u0080 - \\u07FF 和 \\u0000 110XXXXX 10XXXXXX \\u0800 - \\uFFFF 1110XXXX 10XXXXXX 10XXXXXX\n“联通”这两个字符的GBK编码值是“C1 AA CD A8\"，GBK编码方式使用两个字节对一个字符进行编码，因此以GBK编码方式存放的录有“联通”两个字符的文件的大小为四个字节。接下来分别观察“联通”这两个字符GBK编码值的二进制形式，你有发现有趣的事。\n联 GBK 十六进制：C1 AA 二进制：1100 0001,1010 1010 通 GBK 十六进制：C1 AA 二进制：1100 1101,1010 1000\n请注意上面二进制数据的着色部分，你想到了什么？对，它们和UTF-8编码结构中的补充位完全一致，UTF-8编码的补充位使得编码值更有规律，而记事本刚好凭借这个特征区分UTF-8编码的文件。存有“联通”两个字符的文件的所有数据都符合这个特征，就是这样，记事本彻底的将文件误认为UTF-8编码的文件。 将错就错，让我们来看看这个错误是怎样收场的。如果把“联通”的GBK编码值当作UTF-8编码值，那文件就成为一个写有数据“C1 AA CD A8”并以UTF-8编码的文件，当使用记事本再次打开的时候会看到什么呢？只要将UTF-8编码转换成Unicode编码就知道了。UTF-8编码“C1 AA CD A8”转换成Unicode编码后，编码值为“6A 00 68 03”（转换方法请参考本Blog中的《字符编码》一文）。0x006A这个Unicode编码值位于\\u0001 - \\u007E之间，若要转换为UTF-8编码，显然只能用一个字节进行编码，因此“联”的GBK编码“C1 AA”虽然特征上貌似UTF-8编码，但它却不对应任何一个UTF-8编码。接着看0x0368这个Unicode编码值，这个值对应了字符“ͨ”，这也正是我们将在记事本中看到的内容。或许你会说我看到的是一个黑色矩形啊，这只是字体的原因，你将字体改为宋体或者其他字体，看到的就是字符“ͨ”。 对于中文字符，UTF-8编码要用三个字节进行编码，因此，如果你使用记事本录入“联通”，然后选择以UTF-8编码方式保存的话，文件大小应为9个字节（包含三个字节的开头数据），而同样的文件GBK编码却是4个字节。\n    utf-16\nUTF-16编码以16位无符号整数为单位。我们把Unicode\nunicode 编码记作U。编码规则如下： 如果U如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。\n为什么U’可以被写成20个二进制位？Unicode的最大码位是0x10ffff，减去0x10000后，U’的最大值是0xfffff，所以肯定可以用20个二进制位表示。例如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到：1101100001000011 1101110000110000，即0xD843 0xDC30。\n按照上述规则，Unicode编码0x10000-0x10FFFF的UTF-16编码有两个WORD，第一个WORD的高6位是110110，第二个WORD的高6位是110111。可见，第一个WORD的取值范围（二进制）是11011000 00000000到11011011 11111111，即0xD800-0xDBFF。第二个WORD的取值范围（二进制）是11011100 00000000到11011111 11111111，即0xDC00-0xDFFF。\n为了将一个WORD的UTF-16编码与两个WORD的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）： 这里的意思是 unicode编码表中0xD800-0xdfff 是没有被赋予任何的字符的，永远不会有单个字符落在这个区域。\nD800－DB7F High Surrogates 高位替代 DB80－DBFF High Private Use Surrogates 高位专用替代 DC00－DFFF Low Surrogates 低位替代  下边这段高替代位， 低替代位的知识会很难懂， 所以我在最后补充了另外一篇知识。\n高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。 如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制： 1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111 按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到 1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111\n即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代[1]。\n四字节的UTF-16字符的性质与计算\nJavaScript中的字符串是以UTF-16为代码单元。通常我们使用的字符范围都在Unicode值0x10000以内，他们对应的UTF-16就是它们自身。但Unicode中也存在这个范围之外的字符，这时候就需要两个UTF-16字符来描述。这些字符在统计时会被作为两个字符。 比如下面这个字符，虽然只有一个字，但却会统计出两个字符。\n  alert(\"𠐀\".length); //2   因为字符串的length表示的并不是字符个数，而是UTF-16的单元个数。Unicode为UTF-16预留了两块区域，称为“高位替代区”和“低位替代区”。这两个区域的字符单独使用是每一意义的，甚至在某些地方都无法单独使用他们，比如内置的URL转义函数就无法转换这样的字符\n比如说直接使用encodeURIComponent(\"\\uD841\") 是会直接报错的\n在正则表达式中，其也是被作为两个字符来处理的 /^.$/.test(’’) false /^..$/.test(’’) true\n使用charCodeAt的时候也会把它作为两个字符来处理。这些把它当做两个字符处理的情况会分别处理它的“高位替代符”和“低位替代符”。\n维基百科访问地址\n  utf-32\nUTF-32\nUTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。 字节序\n字节序有两种，分别是“大端”（Big Endian, BE）和“小端”（Little Endian, LE）。 根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。例如：\nUnicode编码 UTF-16LE　 UTF-16BE　 UTF32-LE　 UTF32-BE 0x006C49 49 6C 6C 49 49 6C 00 00 00 00 6C 49 0x020C30 43 D8 30 DC D8 43 DC 30 30 0C 02 00 00 02 0C 30  Unicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现在实际传输中。\n  最后得出的结论：\n• 新产品上线尽量使用UTF-8编码,避免多编码存在的混乱局面, 并且满足国际化;\n• 根据业务需求和容量,避免不必要的浪费,例如日志的存储。\n• 发送HTTP请求的时候,注意你的字符编码,一定要与上下游接 收方保持一致。\n","wordCount":"693","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Theme PaperMod"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://materliu.github.io/blog/posts/2014-04-22-charset-utf-ascii/"},"publisher":{"@type":"Organization","name":"知了","logo":{"@type":"ImageObject","url":"https://materliu.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://materliu.github.io/blog accesskey=h title="知了 (Alt + H)">知了</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://materliu.github.io/blog/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://materliu.github.io/blog/archives title=存档><span>存档</span></a></li><li><a href=https://materliu.github.io/blog/categories/ title=分类><span>分类</span></a></li><li><a href=https://materliu.github.io/blog/search/ title=搜索><span>搜索</span></a></li><li><a href=https://materliu.github.io/blog/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://materliu.github.io/blog>主页</a>&nbsp;»&nbsp;<a href=https://materliu.github.io/blog/posts/>Posts</a></div><h1 class=post-title>编码知识梳理</h1><div class=post-meta>4 分钟&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href=https://github.com/materliu/blog/tree/master/content/posts/2014-04-22-charset-utf-ascii.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%bc%96%e7%a0%81%e7%9f%a5%e8%af%86%e6%a2%b3%e7%90%86 aria-label=编码知识梳理>编码知识梳理</a><ul><ul><li><a href=#%e9%a6%96%e5%85%88%e8%a6%81%e6%90%9e%e6%98%8e%e7%99%bd%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98-%e9%82%a3%e5%b0%b1%e6%98%af%e4%bb%80%e4%b9%88%e6%98%af%e5%ad%97%e7%ac%a6 aria-label="首先要搞明白一个问题， 那就是什么是字符">首先要搞明白一个问题， 那就是什么是字符</a></li><li><a href=#%e9%82%a3%e4%bb%80%e4%b9%88%e6%98%af%e5%ad%97%e7%ac%a6%e9%9b%86%e5%91%a2 aria-label=那什么是字符集呢>那什么是字符集呢</a></li><li><a href=#%e9%82%a3%e5%8f%aa%e6%9c%8901%e8%a1%a8%e7%a4%ba%e7%9a%84%e8%ae%a1%e7%ae%97%e6%9c%ba%e6%98%af%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8%e8%bf%99%e4%ba%9b%e5%ad%97%e7%ac%a6%e4%bf%a1%e6%81%af%e7%9a%84%e5%91%a2 aria-label=那只有0，1表示的计算机是如何存储这些字符信息的呢？>那只有0，1表示的计算机是如何存储这些字符信息的呢？</a></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=编码知识梳理>编码知识梳理<a hidden class=anchor aria-hidden=true href=#编码知识梳理>#</a></h1><p>一直以来我对编码知识都倍感疑惑。借着这次整理书库的机会，把之前 joltwang(⺩王辉) 分享的编码知识ppt翻了出来，特此重新梳理一下</p><h3 id=首先要搞明白一个问题-那就是什么是字符>首先要搞明白一个问题， 那就是什么是字符<a hidden class=anchor aria-hidden=true href=#首先要搞明白一个问题-那就是什么是字符>#</a></h3><p>abcd算是 √®∑ø当然也算是 emoij表情符号也算是 夏でも底に冷たさをもつ青いそら 也算是</p><h3 id=那什么是字符集呢>那什么是字符集呢<a hidden class=anchor aria-hidden=true href=#那什么是字符集呢>#</a></h3><p>显而易见把具有相同特征的字符归纳整理到一个集合中就形成了字符集</p><h3 id=那只有01表示的计算机是如何存储这些字符信息的呢>那只有0，1表示的计算机是如何存储这些字符信息的呢？<a hidden class=anchor aria-hidden=true href=#那只有01表示的计算机是如何存储这些字符信息的呢>#</a></h3><p>这就涉及到了编码</p><ol start=2><li><p>字符编码的要素</p><ol><li><p>首先要规定占用存储，也就是说一个字符需要几个字节来表示</p></li><li><p>生成编码规则下的编码表，也就是规定字符与字节序列间的一一对应关系</p></li></ol></li><li><p>ASCII (American Standard Code for Information Interchange)</p></li></ol><p>是基于拉丁字母的一套字符编码，占用一个字节，使用了一个字节中的7位，定义了128个字符，其中33个非显示字符，96个可显示字符</p><p>我们知道，在计算机内部，所有的信息最终都表示成一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000
到11111111</p><p>ASCII编码就是把英语字符和二进制位之间的关系，做了统一规定。比如空格是32（二进制 00100000）， 大写字母A是65（二进制是
01000001）。ACSII只使用了后7位bit，每个字节的第一位bit统一为0。 空格当然算是可显示字符了，至于不可显示字符，多是一些陈废的操控文字的控制字符，但在DOS模式下可显示出一些诸如笑脸，扑克牌花式等符号。</p><p><img loading=lazy src=/attachments/2014-04-22-charset-utf-ascii-1.png alt="not ascii"></p><p>ISO8859实际上是一种字符集标准——拉丁字符集,各个子集都有自 己的字符编码,共有14种字符编码。比如说iso-8859-1 扩展位放置的时德文字符，
iso-8859-7 扩展位放的是希腊字符，这个标准存在的问题就是子集扩展部分互不兼容，只有拉丁字符部分相互兼容。</p><p>英文字符集: 26个字母;</p><p>简体字符集: 85000个,常用汉字:7000个。</p><p>简体字符的编码表远大于拉丁字符的编码表。</p><p>所以我们有了GB系列的编码</p><p>说说GB2312</p><p>借鉴 ISO8859 的编码思想,兼容ASCII,以两个字节为单位存储进行扩展。</p><p><img loading=lazy src=/attachments/2014-04-22-charset-utf-ascii-2.png alt=gb2312></p><p>两个字节就有72 * 94 = 6768种可能,也就是可以表示 6768 种汉 字,GB2312实际收录6763个汉字,占常用汉字的99%。</p><p>存在的问题:很多汉字无法打印出来,比如朱镕基的“镕”,只能使用(金 +容)、(金容)、(左金右容)等来表示。</p><p>诸如此类的， 繁体中文有了 big5 编码， 韩文有了EUC-KR编码， 日文有了SJIS编码</p><p>这样依然存在问题， 这些编码集相互不兼容。</p><p>微软在发行windows95的时候发现了中文简繁体不能共存的问题， 所以提出了gbk编码，</p><p>GBK(kuozhan 扩展)是对GB2312的扩展, 最早实现于Windows 95简体中文版, 双字节存储。</p><p>包含了 gb2312 和 big5 + 少数民族 + 日韩东亚文字</p><p>后来我们国家又提出了 gb18030 编码标准， 被称为国标码 主要工作是对多名族语言的补充,采用多字节编码,每个字可以由1个、2个或4个字 节组成。</p><p>gk18030 包含了gbk以及更丰富的少数民族文字 藏文，满文等</p><p>但是gb18030 仍然解决不了国际化的问题。</p><p>这时候就需要诞生一个国际化的编码标准，首先出现的是一个字符集那就是unicode字符集。</p><p><img loading=lazy src=/attachments/2014-04-22-charset-utf-ascii-3.png alt=unicode字符集>
<img loading=lazy src=/attachments/2014-04-22-charset-utf-ascii-4.png alt=unicode字符集emoij></p><p>需要注意的unicode只是一个字符集， 它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p><p>比如，汉子“严”的unicode表示是4E25，转换成二进制足足有15位</p><p>100111000100101，也就是说这个负号的表示至少需要2个字节。表示其他更大的符号，可能需要3个或者4个字节，甚至更多。</p><p>这里就有两个严重的问题：</p><ol><li><p>如何才能区分unicode和ascii？ 计算机怎么知道三个字节表示一个符号而不是分别表示三个符号呢？</p></li><li><p>我们已经知道英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或者四个字节表示，那么每个英文字母前都必须有两到三个字节全部为0，这对于存储来说是极大的浪费，文本文件的大小会因此大出两到三倍，这是无法接受的。</p></li></ol><p>所以就有了下边的结果：</p><ol><li><p>出现了unicode的多种存储方式。也就是说有许多种不同的二进制格式，可以用来表示unicode字符集</p></li><li><p>unicode在很长一段时间内无法推广，直到互联网的出现</p></li></ol><p>下边就来说一说各种编码方式:</p><ol><li><p>UTF: unicode transformation format</p></li><li><p>utf-8: 可变长的</p></li><li><p>utf-16: 大部分是2个字节</p></li><li><p>utf-32: 4个字节</p></li></ol><p>在Unicode中：汉字“字”对应的数字是23383（十进制），十六进制表示为5B57。在Unicode中，我们有很多方式将数字23383表示成程序中的数据，包括：UTF-8、UTF-16、UTF-32。UTF是“UCS Transformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。例如，“汉字”对应的数字是0x6c49和0x5b57，而编码的程序数据是：</p><p>chardata_utf8[]={0xE6,0xB1,0x89,0xE5,0xAD,0x97};//UTF-8编码</p><p>char16_tdata_utf16[]={0x6C49,0x5B57};//UTF-16编码</p><p>char32_tdata_utf32[]={0x00006C49,0x00005B57};//UTF-32编码</p><p>这里用char、char16_t、char32_t分别表示无符号8位整数，无符号16位整数和无符号32位整数。UTF-8、UTF-16、UTF-32分别以char、char16_t、char32_t作为编码单位。（注： char16_t 和 char32_t 是 C++ 11 标准新增的关键字。如果你的编译器不支持 C++ 11 标准，请改用 unsigned short 和 unsigned long。）“汉字”的UTF-8编码需要6个字节。“汉字”的UTF-16编码需要两个char16_t，大小是4个字节。“汉字”的UTF-32编码需要两个char32_t，大小是8个字节。根据字节序的不同，UTF-16可以被实现为UTF-16LE或UTF-16BE，UTF-32可以被实现为UTF-32LE或UTF-32BE。下面介绍UTF-8、UTF-16、UTF-32、字节序和BOM。[1]</p><ol><li><p>utf-8</p><ol><li><p>与ASCII兼容,这使得原来的软件无须或只须做少部份修改,即 可继续使用。 因此,它逐渐成为电子邮件、网页及其他存储或传送文字的应用 中,优先采用的编码。</p><p>UTF-8文件的Unicode签名BOM(Byte Order Mark)问题</p><p>近日在调测一个UTF8编码的中文Zen Cart网站时遇到一件怪事，网页显示文字正常，用ie的察看源文件（记事本打开）却发现乱码，firefox没有这个问题。经在网上多方查证和多次测试，解决了这个问题，其实是UTF-8文件的Unicode签名BOM(Byte Order Mark)问题。</p><p>BOM(Byte Order Mark)，是UTF编码方案里用于标识编码的标准标记，在UTF-16里本来是FF FE，变成UTF-8就成了EF BB BF。这个标记是可选的，因为UTF8字节没有顺序，所以它可以被用来检测一个字节流是否是UTF-8编码的。微软做这种检测，但有些软件不做这种检测，而把它当作正常字符处理。</p><p>微软在自己的UTF-8格式的文本文件之前加上了EF BB BF三个字节, windows上面的notepad等程序就是根据这三个字节来确定一个文本文件是ASCII的还是UTF-8的, 然而这个只是微软暗自作的标记, 其它平台上并没有对UTF-8文本文件做个这样的标记。</p><p>也就是说一个UTF-8文件可能有BOM，也可能没有BOM，那么怎么区分呢？三种方法。1，用UltraEdit-32打开文件，切换到十六进制编辑模式，察看文件头部是否有EF BB BF。2，用Dreamweaver打开，察看页面属性，看“包括Unicode签名BOM”前面是否有个勾。3，用Windows的记事本打开，选择 “另存为”，看文件的默认编码是UTF-8还是ANSI，如果是ANSI则不带BOM。</p><p>我找到Zen Cart的模版文件中的html_header.php，发现文件果然不带BOM，用UltraEdit-32另存为的方式加上BOM后，再上传html_header.php，一切正常。</p><p>注意用Convertz把gb2312文件转换成UTF-8文件时，默认设置是不带BOM的。不带BOM可能出现上述乱码问题，但是带 BOM，对于php的include文件要小心，会在php字节流前面多出EF BB BF，提前输出到显示器有可能会带来程序错误。一个解决方案是凡是被include的文件都保存为ANSI，主文件可以是UTF-8。要想把一个文件去掉 BOM，使用UlterEdit打开, 切换到十六进制编辑模式，把最前面三个字节(就是那该死的 EF BB BF)替换为20，保存（注意关闭保存时自动备份的功能），再切换到默认编辑模式，把最前面的三个空格去掉就可以了。</p><p>另外还学到一些编码的小知识：所谓的unicode保存的文件实际上是utf-16，只不过恰好跟unicode的码相同而已,但在概念上unicode与utf是两回事，unicode是内存编码表示方案，而utf是如何保存和传输unicode的方案。utf-16还分高位在前 (LE)和高位在后(BE)两种。官方的utf编码还有utf-32，也分LE和BE。非unicode官方的utf编码还有utf-7，主要用于邮件传输。utf-8的单字节部分是和iso-8859-1兼容的，这主要是一些旧的系统和库函数不能正确处理utf-16而被迫出来的，而且对英语字符来说，也节省保存的文件空间（以非英语字符浪费空间为代价）。在iso-8859-1的时候，utf8和iso-8859-1都是用一个字节表示的，当表示其它字符的时候，utf-8会使用两个或三个字节。</p><p>The UTF-8 BOM is a sequence of bytes (EF BB BF) that allows the reader to identify the file as an UTF-8 file.</p><p>Normally, the BOM is used to signal the endianness of the encoding, but since endianness is irrelevant to UTF-8, the BOM is unnecessary.</p><p>According to the Unicode standard, the BOM for UTF-8 files is not recommended:</p><p>Short answer: In UTF-8, a BOM is encoded as the bytes EF BB BF at the beginning of the file.</p><p>Long answer:</p><p>Originally, it was expected that Unicode would be encoded in UTF-16/UCS-2. The BOM was designed for this encoding form. When you have 2-byte code units, it&rsquo;s necessary to indicate which order those two bytes are in, and a common convention for doing this is to include the character U+FEFF as a &ldquo;Byte Order Mark&rdquo; at the beginning of the data. The character U+FFFE is permanently unassigned so that its presence can be used to detect the wrong byte order.</p><p>UTF-8 has the same byte order regardless of platform endianness, so a byte order mark isn&rsquo;t needed. However, it may occur (as the byte sequence EF BB FF) in data that was converted to UTF-8 from UTF-16, or as a &ldquo;signature&rdquo; to indicate that the data is UTF-8.</p><p><a href=http://stackoverflow.com/questions/2223882/whats-different-between-utf-8-and-utf-8-without-bom>stackoverflow上的讨论，知识更多更全</a></p><p>几种编码格式的bom值</p><p>UTF-8</p><p>EF BB BF</p><p>UTF-16</p><p>FF FE</p><p>UTF-16 big endian</p><p>FE FF</p><p>UTF-32</p><p>FF FE 00 00</p><p>UTF-32 big endian</p><p>00 00 FE FF</p></li><li><p>UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：</p><table log-set-param=table_view class="table-view log-set-param"><tbody><tr><td><div class=para><b>Unicode编码(十六进制)　</b></div></td><td><div class=para><b>UTF-8 字节流(二进制)</b></div></td></tr><tr><td><div class=para>000000 - 00007F</div></td><td><div class=para>0xxxxxxx</div></td></tr><tr><td><div class=para>000080 - 0007FF</div></td><td><div class=para>110xxxxx 10xxxxxx</div></td></tr><tr><td><div class=para>000800 - 00FFFF</div></td><td><div class=para>1110xxxx 10xxxxxx 10xxxxxx</div></td></tr><tr><td><div class=para>010000 - 10FFFF</div></td><td><div class=para>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</div></td></tr></tbody></table><p>UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。</p><p>例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p><p>例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用用4字节模板了：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。</p><p>移动比联通强的原因是记事本无法显示“联通”?</p><p>流言：</p><hr><p>在Windows操作系统中使用记事本新建一个文本文件，在文件里面写入“联通”两个字并保存。当再次打开这个文本文件时候，在记事本中看到得却不是刚刚输入的“联通”，而是乱码。这就是移动比联通强的原因！</p><hr><p>粉碎：
出现上述问题本质上是：GB2312与UTF-8编码冲突所致。首先普及一下编码常识：
ASCII的霸权：
起初，是一些人想用8个晶体的亮灭表示世间万物，于是产生了“编码”，最早是美国人发明了ASCII字符集(American Standard Code for Information Interchange，美国信息互换标准代码）用来存储英文字符，一个字节8位，可以表示2^8=256个符号，其中0~32特殊用途（0x20以下）；32~127 存储 英文；128~255为扩展字符集；
GB2312的来历：
中国人想用电脑读写汉字，256个字符不够用怎么办？于是果断舍弃127之后没用的字符，并且在ASCII的基础上规定如果一个字符小于127则表示原字符，即所谓的半角字符，如果连续两个字符大于127则表示一个汉字，即全角字符。这就是GB2312，它实际是ASCII的中文扩展。
都来又有GBK，GB18030，都是对汉字字符集的扩充。
UNICODE的大一统：
一个叫 ISO （国际标谁化组织）的国际组织决定用16位来表示地球上所有文字，于是产生传说中的"Universal Multiple-Octet Coded Character Set"，简称 UCS, 俗称 &ldquo;UNICODE&rdquo;。它规定两个字节为一个字符，英文高8位都是0，但问题是GBK 与UNICODE 在汉字内码编码完全不同。这为谣言埋下了伏笔&mldr;.
UTF8的传输：
互联网上70%的内容是英文，而UNICODE英文高8位为0，如果采用UNICODE传输无疑造成空间浪费，于是产生UTF8即每次8个位传输数据，当然还有UTF16，UTF32，都是按一定规则转化后的编码形式。</p><p>这样就可以解释记事本不能显示的问题了，实际上，“联通”这两个字符的GBK编码具有UTF-8编码的特征，记事本犯下的错误正是将GBK编码存放的记录有“联通”两个字符的文件误认为UTF-8编码的文件。</p><p>细节（有兴趣看下）：
UTF-8编码采用1-3个字节对字符进行编码，编码字节数与字符的Unicode编码值有严格的对应关系，让我们回忆下UTF-8编码和Unicode的对应关系吧。</p><p>Unicode编码值 UTF-8编码结构
\u0001 - \u007E 0XXXXXXX
\u0080 - \u07FF 和 \u0000 110XXXXX 10XXXXXX
\u0800 - \uFFFF 1110XXXX 10XXXXXX 10XXXXXX</p><p>“联通”这两个字符的GBK编码值是“C1 AA CD A8"，GBK编码方式使用两个字节对一个字符进行编码，因此以GBK编码方式存放的录有“联通”两个字符的文件的大小为四个字节。接下来分别观察“联通”这两个字符GBK编码值的二进制形式，你有发现有趣的事。</p><p>联 GBK 十六进制：C1 AA 二进制：1100 0001,1010 1010
通 GBK 十六进制：C1 AA 二进制：1100 1101,1010 1000</p><p>请注意上面二进制数据的着色部分，你想到了什么？对，它们和UTF-8编码结构中的补充位完全一致，UTF-8编码的补充位使得编码值更有规律，而记事本刚好凭借这个特征区分UTF-8编码的文件。存有“联通”两个字符的文件的所有数据都符合这个特征，就是这样，记事本彻底的将文件误认为UTF-8编码的文件。
将错就错，让我们来看看这个错误是怎样收场的。如果把“联通”的GBK编码值当作UTF-8编码值，那文件就成为一个写有数据“C1 AA CD A8”并以UTF-8编码的文件，当使用记事本再次打开的时候会看到什么呢？只要将UTF-8编码转换成Unicode编码就知道了。UTF-8编码“C1 AA CD A8”转换成Unicode编码后，编码值为“6A 00 68 03”（转换方法请参考本Blog中的《字符编码》一文）。0x006A这个Unicode编码值位于\u0001 - \u007E之间，若要转换为UTF-8编码，显然只能用一个字节进行编码，因此“联”的GBK编码“C1 AA”虽然特征上貌似UTF-8编码，但它却不对应任何一个UTF-8编码。接着看0x0368这个Unicode编码值，这个值对应了字符“ͨ”，这也正是我们将在记事本中看到的内容。或许你会说我看到的是一个黑色矩形啊，这只是字体的原因，你将字体改为宋体或者其他字体，看到的就是字符“ͨ”。
对于中文字符，UTF-8编码要用三个字节进行编码，因此，如果你使用记事本录入“联通”，然后选择以UTF-8编码方式保存的话，文件大小应为9个字节（包含三个字节的开头数据），而同样的文件GBK编码却是4个字节。</p></li></ol></li><li><p>utf-16</p><p>UTF-16编码以16位无符号整数为单位。我们把Unicode</p><p>unicode
编码记作U。编码规则如下：
如果U&lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。</p><p>如果U≥0x10000，我们先计算U&rsquo;=U-0x10000，然后将U&rsquo;写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。</p><p>为什么U&rsquo;可以被写成20个二进制位？Unicode的最大码位是0x10ffff，减去0x10000后，U&rsquo;的最大值是0xfffff，所以肯定可以用20个二进制位表示。例如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到：1101100001000011 1101110000110000，即0xD843 0xDC30。</p><p>按照上述规则，Unicode编码0x10000-0x10FFFF的UTF-16编码有两个WORD，第一个WORD的高6位是110110，第二个WORD的高6位是110111。可见，第一个WORD的取值范围（二进制）是11011000 00000000到11011011 11111111，即0xD800-0xDBFF。第二个WORD的取值范围（二进制）是11011100 00000000到11011111 11111111，即0xDC00-0xDFFF。</p><p>为了将一个WORD的UTF-16编码与两个WORD的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）： 这里的意思是 unicode编码表中0xD800-0xdfff 是没有被赋予任何的字符的，永远不会有单个字符落在这个区域。</p><table log-set-param=table_view class="table-view log-set-param"><tbody><tr><td><div class=para>D800－DB7F</div></td><td><div class=para>High Surrogates</div></td><td><div class=para>高位替代</div></td></tr><tr><td><div class=para>DB80－DBFF</div></td><td><div class=para>High Private Use Surrogates</div></td><td><div class=para>高位专用替代</div></td></tr><tr><td><div class=para>DC00－DFFF</div></td><td><div class=para>Low Surrogates</div></td><td><div class=para>低位替代</div></td></tr></tbody></table><p>下边这段高替代位， 低替代位的知识会很难懂， 所以我在最后补充了另外一篇知识。</p><p>高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。
如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：
1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111
按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到
1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111</p><p>即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代[1]。</p><p>四字节的UTF-16字符的性质与计算</p><p>JavaScript中的字符串是以UTF-16为代码单元。通常我们使用的字符范围都在Unicode值0x10000以内，他们对应的UTF-16就是它们自身。但Unicode中也存在这个范围之外的字符，这时候就需要两个UTF-16字符来描述。这些字符在统计时会被作为两个字符。
　　比如下面这个字符，虽然只有一个字，但却会统计出两个字符。</p><pre><code> &lt;script&gt;
 alert(&quot;𠐀&quot;.length); //2
 &lt;/script&gt;
</code></pre><p>因为字符串的length表示的并不是字符个数，而是UTF-16的单元个数。Unicode为UTF-16预留了两块区域，称为“高位替代区”和“低位替代区”。这两个区域的字符单独使用是每一意义的，甚至在某些地方都无法单独使用他们，比如内置的URL转义函数就无法转换这样的字符</p><p>比如说直接使用encodeURIComponent("\uD841") 是会直接报错的</p><p>在正则表达式中，其也是被作为两个字符来处理的 /^.$/.test(&rsquo;&rsquo;) false /^..$/.test(&rsquo;&rsquo;) true</p><p>使用charCodeAt的时候也会把它作为两个字符来处理。这些把它当做两个字符处理的情况会分别处理它的“高位替代符”和“低位替代符”。</p><p><a href=http://en.wikipedia.org/wiki/UTF-16/UCS-2#Code_points_U.2B10000..U.2B10FFFF>维基百科访问地址</a></p></li><li><p>utf-32</p><p>UTF-32</p><p>UTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。
字节序</p><p>字节序有两种，分别是“大端”（Big Endian, BE）和“小端”（Little Endian, LE）。
根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。例如：</p><table log-set-param=table_view class="table-view log-set-param"><tbody><tr><td><div class=para><b>Unicode编码</b></div></td><td><div class=para><b>UTF-16LE　</b></div></td><td><div class=para><b>UTF-16BE　</b></div></td><td><div class=para><b>UTF32-LE　</b></div></td><td><div class=para><b>UTF32-BE</b></div></td></tr><tr><td><div class=para>0x006C49</div></td><td><div class=para>49 6C</div></td><td><div class=para>6C 49</div></td><td><div class=para>49 6C 00 00</div></td><td><div class=para>00 00 6C 49</div></td></tr><tr><td><div class=para>0x020C30</div></td><td><div class=para>43 D8 30 DC</div></td><td><div class=para>D8 43 DC 30</div></td><td><div class=para>30 0C 02 00</div></td><td><div class=para>00 02 0C 30</div></td></tr></tbody></table><p>Unicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现在实际传输中。</p></li></ol><p>最后得出的结论：</p><p>• 新产品上线尽量使用UTF-8编码,避免多编码存在的混乱局面, 并且满足国际化;</p><p>• 根据业务需求和容量,避免不必要的浪费,例如日志的存储。</p><p>• 发送HTTP请求的时候,注意你的字符编码,一定要与上下游接 收方保持一致。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://materliu.github.io/blog/posts/2014-03-26-window.onerror%E4%B8%8D%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84/><span class=title>« 上一页</span><br><span>window.onError不是万能的</span></a>
<a class=next href=https://materliu.github.io/blog/posts/2014-12-17-huginn/><span class=title>下一页 »</span><br><span>机器安装huginn</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 编码知识梳理 on twitter" href="https://twitter.com/intent/tweet/?text=%e7%bc%96%e7%a0%81%e7%9f%a5%e8%af%86%e6%a2%b3%e7%90%86&url=https%3a%2f%2fmaterliu.github.io%2fblog%2fposts%2f2014-04-22-charset-utf-ascii%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 编码知识梳理 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmaterliu.github.io%2fblog%2fposts%2f2014-04-22-charset-utf-ascii%2f&title=%e7%bc%96%e7%a0%81%e7%9f%a5%e8%af%86%e6%a2%b3%e7%90%86&summary=%e7%bc%96%e7%a0%81%e7%9f%a5%e8%af%86%e6%a2%b3%e7%90%86&source=https%3a%2f%2fmaterliu.github.io%2fblog%2fposts%2f2014-04-22-charset-utf-ascii%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 编码知识梳理 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmaterliu.github.io%2fblog%2fposts%2f2014-04-22-charset-utf-ascii%2f&title=%e7%bc%96%e7%a0%81%e7%9f%a5%e8%af%86%e6%a2%b3%e7%90%86"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 编码知识梳理 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmaterliu.github.io%2fblog%2fposts%2f2014-04-22-charset-utf-ascii%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 编码知识梳理 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%bc%96%e7%a0%81%e7%9f%a5%e8%af%86%e6%a2%b3%e7%90%86%20-%20https%3a%2f%2fmaterliu.github.io%2fblog%2fposts%2f2014-04-22-charset-utf-ascii%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 编码知识梳理 on telegram" href="https://telegram.me/share/url?text=%e7%bc%96%e7%a0%81%e7%9f%a5%e8%af%86%e6%a2%b3%e7%90%86&url=https%3a%2f%2fmaterliu.github.io%2fblog%2fposts%2f2014-04-22-charset-utf-ascii%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><form name=contact method=post data-netlify=true><p><label>Your Name: <input type=text name=name></label></p><p><label>Your Email: <input type=email name=email></label></p><p><label>Message: <textarea name=message></textarea></label></p><p><button type=submit>Send</button></p></form></article></main><footer class=footer><span>&copy; 2022 <a href=https://materliu.github.io/blog>知了</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>var href=location.href;href.match(/materliu\.github\.io/g)&&(location.href="https://materliu.netlify.app/")</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="复制";function s(){e.innerHTML="已复制！",setTimeout(()=>{e.innerHTML="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>